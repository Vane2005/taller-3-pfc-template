/*
 * This Scala source file was generated by the Gradle 'init' task.
 */
package taller
import org.scalameter.withWarmer
import org.scalameter.Warmer
import org.scalameter.measure
import org.scalameter.Warmer.Default
import scala.collection.parallel.CollectionConverters._
import scala.util.Random


object App {
  def main(args: Array[String]): Unit = {
    val regado = new Regado()
    val finca = regado.fincaAlAzar(5)  //los valores n se van cambiando para realizar las pruebas
    val progRiego = regado.generarProgRiegoAlAzar(10)

    
    val finca1 = regado.fincaAlAzar(1)
    val finca2 = regado.fincaAlAzar(1)

    val finca3 = regado.fincaAlAzar(2)
    val finca4 = regado.fincaAlAzar(2)

    val finca5 = regado.fincaAlAzar(3)
    val finca6 = regado.fincaAlAzar(3)

    val finca7 = regado.fincaAlAzar(4)
    val finca8 = regado.fincaAlAzar(4)

    val finca9 = regado.fincaAlAzar(5)
    val finca10 = regado.fincaAlAzar(5)

    //Pruebas para costoRiegoFinca
    def pruebas1(): Unit = {
      val comp = regado.compararCostoRiegoFinca(regado.costoRiegoFinca, regado.costoRiegoFincaPar)(finca, progRiego)
      println("Secuencial: " + comp(0))
      println("Paralelo: " + comp(1))
    }

    def imprimirVectorFormateado(vector: Vector[Vector[Int]]): String = {
      vector.zipWithIndex.map { case (subVector, index) =>
        s"  $index: " + subVector.mkString("(", ", ", ")")
      }.mkString("\n")
    }

    //Pruebas para generarProgramacionesRiego

    def pruebas2(): Unit = {
      println("finca9: \n" + imprimirVectorFormateado(finca9.map { case (a, b, c) => Vector(a, b, c) }))
      println("Programación de riego con secuencial:\n" + regado.generarProgramacionesRiego(finca9))
      println("Programación de riego con paralela: \n" + regado.generarProgramacionesRiegoPar(finca9))
      val comp1 = regado.compararGenerarProgramacionesRiego(regado.generarProgramacionesRiego, regado.generarProgramacionesRiegoPar)(finca9)
      println("Secuencial: " + comp1(0))
      println("Paralelo: " + comp1(1))
      println("Aceleración: " + comp1(2))


      println("\nfinca10: \n" + imprimirVectorFormateado(finca10.map { case (a, b, c) => Vector(a, b, c) }))
      println("Programación de riego con secuencial:\n" + regado.generarProgramacionesRiego(finca10))
      println("Programación de riego con paralela: \n" + regado.generarProgramacionesRiegoPar(finca10))
      val comp2 = regado.compararGenerarProgramacionesRiego(regado.generarProgramacionesRiego, regado.generarProgramacionesRiegoPar)(finca10)
      println("Secuencial: " + comp1(0))
      println("Paralelo: " + comp1(1))
      println("Aceleración: " + comp1(2))
    }
    pruebas2()


    // Pruebas de costoRiegoTablon
    def pruebasCostoRiegoTablon(): Unit = {
      val finca1 = regado.fincaAlAzar(1)
      val finca2 = regado.fincaAlAzar(2)
      val finca3 = regado.fincaAlAzar(3)
      val finca4 = regado.fincaAlAzar(4)
      val finca5 = regado.fincaAlAzar(5)

      println("\n== Pruebas de costoRiegoTablon ==")
      println(regado.costoRiegoTablon(0, finca1, regado.generarProgRiegoAlAzar(1)))
      println(regado.costoRiegoTablon(0, finca2, regado.generarProgRiegoAlAzar(2)))
      println(regado.costoRiegoTablon(0, finca3, regado.generarProgRiegoAlAzar(3)))
      println(regado.costoRiegoTablon(0, finca4, regado.generarProgRiegoAlAzar(4)))
      println(regado.costoRiegoTablon(0, finca5, regado.generarProgRiegoAlAzar(5)))
    }
    pruebasCostoRiegoTablon()
    pruebasCostoMovilidad(regado)

  }

  def pruebasCostoMovilidad(regado: Regado): Unit = {
  println("\n== Pruebas de Costo Movilidad ==")
  
  (1 to 10).foreach { size =>
      val finca = regado.fincaAlAzar(size) // Genera una finca con 'size' tablones
      val progRiego = regado.generarProgRiegoAlAzar(size) // Genera la programación de riego
      val distancias = regado.distanciaAlAzar(size) // Genera la matriz de distancias

      val resultados = regado.compararCostoMovilidad(
        regado.costoMovilidad, regado.costoMovilidadPar)(finca, progRiego, distancias)

      val tiempoSec = resultados(0)
      val tiempoPar = resultados(1)
      val aceleracion = resultados(2)
      val aceleracionPorcentaje = (aceleracion - 1) * 100

      // Mostrar resultados como texto
      println(s"\nPrueba $size:")
      println(f"Tamaño de la finca: $size")
      println(f"Tiempo secuencial: $tiempoSec%.2f ms")
      println(f"Tiempo paralelo: $tiempoPar%.2f ms")
      println(f"Aceleración: $aceleracion%.2f (${aceleracionPorcentaje}%.2f%%)")
    }
  }
}
